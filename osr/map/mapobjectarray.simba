{$DEFINE SRL_MAPOBJECTARRAY_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL-T/osr.simba}
{$ENDIF}

type
  PRSMapObjectArray = array of Pointer;

function PRSMapObjectArray.GetClosest(): PRSMapObject;
var
  meObj, meNPC: TPoint = [0,0];
  tmp: PRSMapObject;
  i: Int32;
  closest: Double = $FFFFFF;
  current: Double;
begin
  for i := High(Self) downto 0 do
  begin
    tmp := PRSMapObject(Self[i]);

    case tmp^.MapObjectType of
      ERSMapObjectType.OBJ:
      begin
        if meObj = [0,0] then meObj := tmp^.Walker^.Position();
        current := tmp^.Coordinates.NearestPoint(meObj).DistanceTo(meObj);
      end;

      ERSMapObjectType.MMDOT:
      begin
        if meNPC = [0,0] then meNPC := tmp^.Walker^.Position();
        current := tmp^.Coordinates.NearestPoint(meNPC).DistanceTo(meNPC);
      end;
    end;

    if current < closest then
    begin
      closest := current;
      Result := tmp;
    end;
  end;
end;

type
  TRSObjectV2Array = array of TRSObjectV2;

function TRSObjectV2Array.FindAnyID(id: Int32): Int32;
begin
  for Result := 0 to High(Self) do
    if Self[Result].ID = id then
      Exit;
  Result := -1;
end;

function TRSObjectV2Array.FindAnyName(name: String): Int32;
begin
  name := LowerCase(name);
  for Result := 0 to High(Self) do
    if LowerCase(Self[Result].Name) = name then
      Exit;
  Result := -1;
end;

function TRSObjectV2Array.FindAnyType(objType: Int32): Int32;
begin
  for Result := 0 to High(Self) do
    if Self[Result].ObjType = objType then
      Exit;
  Result := -1;
end;

function TRSObjectV2Array.FindAnyCategory(category: Int32): Int32;
begin
  for Result := 0 to High(Self) do
    if Self[Result].Category = category then
      Exit;
  Result := -1;
end;

function TRSObjectV2Array.FindAny(obj: Variant): Int32;
var
  str: String;
begin
  str := obj;
  if VarIsNumeric(obj) or str.IsDigit() then
    Exit(Self.FindAnyID(obj));
  Result := Self.FindAnyName(str);
end;


function TRSObjectV2Array.FindAllName(name: String): TIntegerArray;
var
  i: Int32;
begin
  name := LowerCase(name);
  for i := 0 to High(Self) do
    if Self[i].Name = name then
      Result += i;
end;

function TRSObjectV2Array.FindAllType(objType: Int32): TIntegerArray;
var
  i: Int32;
begin
  for i := 0 to High(Self) do
    if Self[i].ObjType = objType then
      Result += i;
end;

function TRSObjectV2Array.FindAllCategory(category: Int32): TIntegerArray;
var
  i: Int32;
begin
  for i := 0 to High(Self) do
    if Self[i].Category = category then
      Result += i;
end;


type
  TRSNPCV2Array = array of TRSNPCV2;

function TRSNPCV2Array.FindAnyID(id: Int32): Int32;
begin
  for Result := 0 to High(Self) do
    if Self[Result].ID = id then
      Exit;
  Result := -1;
end;

function TRSNPCV2Array.FindAnyName(name: String): Int32;
begin
  name := LowerCase(name);
  for Result := 0 to High(Self) do
    if LowerCase(Self[Result].Name) = name then
      Exit;
  Result := -1;
end;

function TRSNPCV2Array.FindAnyCategory(category: Int32): Int32;
begin
  for Result := 0 to High(Self) do
    if Self[Result].Category = category then
      Exit;
  Result := -1;
end;

function TRSNPCV2Array.FindAny(obj: Variant): Int32;
var
  str: String;
begin
  str := obj;
  if VarIsNumeric(obj) or str.IsDigit() then
    Exit(Self.FindAnyID(obj));
  Result := Self.FindAnyName(str);
end;


function TRSNPCV2Array.FindAllName(name: String): TIntegerArray;
var
  i: Int32;
begin
  name := LowerCase(name);
  for i := 0 to High(Self) do
    if Self[i].Name = name then
      Result += i;
end;

function TRSNPCV2Array.FindAllCategory(category: Int32): TIntegerArray;
var
  i: Int32;
begin
  for i := 0 to High(Self) do
    if Self[i].Category = category then
      Result += i;
end;


type
  TRSMapObjects = record
    Data: TJSONArray;
    Walker: PRSWalkerV2;
    Cache: TRSObjectV2Array;
  end;

procedure TRSMapObjects.Setup(json: TJSONArray; walker: PRSWalkerV2);
begin
  Self.Data := json;
  Self.Walker := walker;
end;


function TRSMapObjects.GetIndex(obj: Variant): Int32;
var
  i: Int32;
  str: String;
  mapNPC: TRSObjectV2;
begin
  Result := Self.Cache.FindAny(obj);
  if Result > -1 then
    Exit;

  if VarIsNumeric(obj) then
  begin
    for i := 0 to  Self.Data.High() do
      if Self.Data.getJSONObject(i).getInt('id') = obj then
      begin
        mapNPC := TRSObjectV2.Setup(Self.Walker, Self.Data.getJSONObject(i));
        mapNPC.Index := Length(Self.Cache);
        Self.Cache += mapNPC;
        Exit(mapNPC.Index);
      end;

    TerminateScript('Object with ID ' + ToStr(obj) + ' doesn''t exist on the loaded maps.');
  end;

  str := LowerCase(obj);

  if str.IsDigit() then
  begin
    for i := 0 to  Self.Data.High() do
      if Self.Data.getJSONObject(i).getInt('id') = obj then
      begin
        mapNPC := TRSObjectV2.Setup(Self.Walker, Self.Data.getJSONObject(i));
        mapNPC.Index := Length(Self.Cache);
        Self.Cache += mapNPC;
        Exit(mapNPC.Index);
      end;

    TerminateScript('Object with ID ' + ToStr(obj) + ' doesn''t exist on the loaded maps.');
  end;

  for i := 0 to Self.Data.High() do
  begin
    if LowerCase(Self.Data.getJSONObject(i).getString('name')) = str then
    begin
      if Result > -1 then
      begin
        if Self.Cache[Result].SameObject(Self.Data.getJSONObject(i)) then
          Self.Cache[Result] := Self.Cache[Result].Merge(Self.Data.getJSONObject(i));
        Continue;
      end;

      mapNPC := TRSObjectV2.Setup(Self.Walker, Self.Data.getJSONObject(i));
      mapNPC.Index := Length(Self.Cache);
      Self.Cache += mapNPC;
      Result := mapNPC.Index;
    end;
  end;

  if Result > -1 then
    TerminateScript('Object ' + ToStr(obj) + ' doesn''t exist on the loaded maps.');
end;

function TRSMapObjects.GetIndices(name: String): TIntegerArray;
var
  i: Int32;
  mapObj: TRSObjectV2;
begin
  name := LowerCase(name);
  Result := Self.Cache.FindAllName(name);
  if Result <> [] then
    Exit;

  for i := 0 to Self.Data.High() do
    if LowerCase(Self.Data.getJSONObject(i).getString('name')) = name then
    begin
      mapObj := TRSObjectV2.Setup(Self.Walker, Self.Data.getJSONObject(i));
      mapObj.Index := Length(Self.Cache);
      Self.Cache += mapObj;
      Result += mapObj.Index;
    end;
end;

function TRSMapObjects.GetIndices(names: TStringArray): TIntegerArray; overload;
var
  name: String;
begin
  for name in names do
    Result += Self.GetIndices(name);
end;

function TRSMapObjects.Get(obj: Variant): TRSObjectV2;
begin
  Result := Self.Cache[Self.GetIndex(obj)];
end;


procedure TRSMapObjects.Add(obj: TRSObjectV2);
begin
  obj.Index := Length(Self.Cache);
  Self.Cache += obj;
end;


procedure TRSMapObjects.SetFinder(obj: Variant; finder: TRSObjectFinder);
begin
  Self.Cache[Self.GetIndex(obj)].Finder := finder;
end;

procedure TRSMapObjects.SetOffset(obj: Variant; offset: TPoint);
begin
  Self.Cache[Self.GetIndex(obj)].Offset := offset;
end;

procedure TRSMapObjects.Debug();
var
  i, j: Int32;
  actions: TStringArray;
  colors: TIntegerArray;
begin
  for i := 0 to  Self.Data.High() do with Self.Data.getJSONObject(i) do
  begin
    for j := 0 to getJSONArray('actions').High() do
      actions += getJSONArray('actions').getString(j);

    for j := 0 to getJSONArray('colors').High() do
      colors += getJSONArray('colors').getInt(j);

    WriteLn(
      'ID: ', getInt('id'), ', Name: ', getString('name'),
      ', Type: ', getInt('type'), ', Category: ', getInt('category'),
      ', Actions: ', actions, ', Colors: ', colors
    );
    actions := [];
    colors := [];
  end;
end;

type
  TRSMapNPCs = record
    Data: TJSONArray;
    Walker: PRSWalkerV2;
    Cache: TRSNPCV2Array;
  end;

procedure TRSMapNPCs.Setup(json: TJSONArray; walker: PRSWalkerV2);
begin
  Self.Data := json;
  Self.Walker := walker;
end;


function TRSMapNPCs.GetIndex(npc: Variant): Int32;
var
  i: Int32;
  str: String;
  mapNPC: TRSNPCV2;
begin
  Result := Self.Cache.FindAny(npc);
  if Result > -1 then
    Exit;

  if VarIsNumeric(npc) then
  begin
    for i := 0 to  Self.Data.High() do
      if Self.Data.getJSONObject(i).getInt('id') = npc then
      begin
        mapNPC := TRSNPCV2.Setup(Self.Walker, Self.Data.getJSONObject(i));
        mapNPC.Index := Length(Self.Cache);
        Self.Cache += mapNPC;
        Exit(mapNPC.Index);
      end;

    TerminateScript('NPC with ID ' + ToStr(npc) + ' doesn''t exist on the loaded maps.');
  end;

  str := LowerCase(npc);

  if str.IsDigit() then
  begin
    for i := 0 to  Self.Data.High() do
      if Self.Data.getJSONObject(i).getInt('id') = npc then
      begin
        mapNPC := TRSNPCV2.Setup(Self.Walker, Self.Data.getJSONObject(i));
        mapNPC.Index := Length(Self.Cache);
        Self.Cache += mapNPC;
        Exit(mapNPC.Index);
      end;

    TerminateScript('NPC with ID ' + ToStr(npc) + ' doesn''t exist on the loaded maps.');
  end;

  for i := 0 to Self.Data.High() do
  begin
    if LowerCase(Self.Data.getJSONObject(i).getString('name')) = str then
    begin
      if Result > -1 then
      begin
        if Self.Cache[Result].SameObject(Self.Data.getJSONObject(i)) then
          Self.Cache[Result] := Self.Cache[Result].Merge(Self.Data.getJSONObject(i));
        Continue;
      end;

      mapNPC := TRSNPCV2.Setup(Self.Walker, Self.Data.getJSONObject(i));
      mapNPC.Index := Length(Self.Cache);
      Self.Cache += mapNPC;
      Result := mapNPC.Index
    end;
  end;

  if Result > -1 then
    TerminateScript('NPC ' + ToStr(npc) + ' doesn''t exist on the loaded maps.');
end;

function TRSMapNPCs.GetIndices(name: String): TIntegerArray;
var
  i: Int32;
  resultNPC: TRSNPCV2;
begin
  name := LowerCase(name);
  Result := Self.Cache.FindAllName(name);

  if Result <> [] then
    Exit;

  for i := 0 to Self.Data.High() do
    if LowerCase(Self.Data.getJSONObject(i).getString('name')) = name then
    begin
      resultNPC := TRSNPCV2.Setup(Self.Walker, Self.Data.getJSONObject(i));
      resultNPC.Index := Length(Self.Cache);
      Self.Cache += resultNPC;
      Result += resultNPC.Index;
    end;
end;

function TRSMapNPCs.GetIndices(names: TStringArray): TIntegerArray; overload;
var
  name: String;
begin
  for name in names do
    Result += Self.GetIndices(name);
end;


function TRSMapNPCs.Get(npc: Variant): TRSNPCV2;
begin
  Result := Self.Cache[Self.GetIndex(npc)];
end;


procedure TRSMapNPCs.Add(npc: TRSNPCV2);
begin
  npc.Index := Length(Self.Cache);
  Self.Cache += npc;
end;

procedure TRSMapNPCs.SetFinder(npc: Variant; finder: TRSObjectFinder);
begin
  Self.Cache[Self.GetIndex(npc)].Finder := finder;
end;

procedure TRSMapNPCs.SetOffset(npc: Variant; offset: TPoint);
begin
  Self.Cache[Self.GetIndex(npc)].Offset := offset;
end;

procedure TRSMapNPCs.Debug();
var
  i, j: Int32;
  actions: TStringArray;
  colors: TIntegerArray;
begin
  for i := 0 to  Self.Data.High() do with Self.Data.getJSONObject(i) do
  begin
    for j := 0 to getJSONArray('actions').High() do
      actions += getJSONArray('actions').getString(j);

    for j := 0 to getJSONArray('colors').High() do
      colors += getJSONArray('colors').getInt(j);

    WriteLn(
      'ID: ', getInt('id'), ', Name: ', getString('name'),
      ', Type: ', getInt('type'), ', Category: ', getInt('category'),
      ', Actions: ', actions, ', Colors: ', colors
    );
    actions := [];
    colors := [];
  end;
end;

var
  Objects: TRSMapObjects;
  NPCs: TRSMapNPCs;
  Banks: PRSMapObjectArray;

{%codetools off}
procedure TRSBank._SetupMapObjects();
var
  i: Int32;
begin
  if Objects <> [] then
    for i in Objects.GetIndices(['Bank booth', 'Bank chest']) do
      Banks += @Objects.Cache[i];

  if NPCs <> [] then
    for i in NPCs.GetIndices('Banker') do
      Banks += @NPCs.Cache[i];
end;
{%codetools on}

function TRSBank.HoverV2(mapObj: PRSMapObject = nil): Boolean; overload;
begin
  if RSInterface.IsOpen() then
    Exit;

  if mapObj = nil then
  begin
    if Banks = [] then
      Self._SetupMapObjects();
    if Banks = [] then
      Exit;

    mapObj := Banks.GetClosest();
  end;

  Result := mapObj^.Hover();
end;

function TRSBank.OpenV2(mapObj: PRSMapObject = nil): Boolean; overload;
begin
  if RSInterface.IsOpen() then
  begin
    if Self.IsOpen() or BankPin.IsOpen() then
      Exit(True);
    RSInterface.Close(True);
  end;

  if mapObj = nil then
  begin
    if Banks = [] then
      Self._SetupMapObjects();
    if Banks = [] then
      Exit;

    mapObj := Banks.GetClosest();
  end;

  Result := mapObj^.Click() or (MainScreen.IsUpText('Banker') and ChooseOption.Select(['Bank B', 'Bank E']));

  if not Result then
    Exit;

  //Minimap.WaitMoving();
  Result := WaitUntil(Self.IsOpen() or BankPin.IsOpen(), SRL.TruncatedGauss(50, 1500), 3000);
end;

function TRSBank.WalkHoverV2(mapObj: PRSMapObject = nil): Boolean; overload;
begin
  if RSInterface.IsOpen() then
    Exit;

  if mapObj = nil then
  begin
    if Banks = [] then
      Self._SetupMapObjects();
    if Banks = [] then
      Exit;

    mapObj := Banks.GetClosest();
  end;

  Result := mapObj^.WalkHover();
end;

function TRSBank.WalkOpenV2(mapObj: PRSMapObject = nil): Boolean; overload;
begin
  if RSInterface.IsOpen() then
  begin
    if Self.IsOpen() or BankPin.IsOpen() then
      Exit(True);
    RSInterface.Close(True);
  end;

  if mapObj = nil then
  begin
    if Banks = [] then
      Self._SetupMapObjects();
    if Banks = [] then
      Exit;

    mapObj := Banks.GetClosest();
  end;

  Result := mapObj^.WalkClick() or (MainScreen.IsUpText('Banker') and ChooseOption.Select(['Bank B', 'Bank E']));

  if not Result then
    Exit;

  Minimap.WaitMoving();
  Result := WaitUntil(Self.IsOpen(), SRL.TruncatedGauss(50, 1500), 3000);
end;
