(*
# Map Objects
This file is responsible for interacting with map objects.
*)

{$DEFINE SRL_MAPOBJECTS_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL-T/osr.simba}
{$ENDIF}

type
  TRSMapObject = record
    ID: Int32;
    Name: String;
    ObjType:  Int32;
    Category: Int32;
    Actions: TStringArray;
    Coordinates: TPointArray;
    Shapes: TRSMainScreenShapeArray;
    Finder: TRSObjectFinder;

    {%codetools off}
    //hidden so you don't touch.
    Walker: PRSWalkerV2;
    Index: Int32;
    {%codetools on}

    Filter: record
      Walker:     Boolean;
      MinimapDot: Boolean;
      Finder:     Boolean;
      UpText:     Boolean;
    end;

  class var
    CurrentUpText: TStringArray;
    CurrentActionUpText: TStringArray;
    RedClicked: Boolean;
  end;

function TRSMapObject.Setup(pwalker: PRSWalkerV2; json: TJSONObject): TRSMapObject; static;
var
  i, x, y, z: Int32;
begin
  Result.ID := json.getInt('id');
  Result.Name := json.getString('name');
  Result.ObjType := json.getInt('type');
  Result.Category := json.getInt('category');

  with json.getJSONArray('actions') do
    for i := 0 to High() do
      if getString(i) <> 'null' then
        Result.Actions += getString(i);

  with json.getJSONArray('coordinates') do
    for i := 0 to High() do
      with getJSONArray(i) do
        Result.Coordinates += [getInt(0), getInt(1)];

  with json.getJSONArray('size') do
  begin
    x := getInt(0);
    y := getInt(1);
    if High() > 1 then
      z := getInt(3)
    else
      z := 0;
  end;

  Result.Walker := pwalker;

  with json.getJSONArray('rotations') do
  begin
    if x = y then
    begin
      for i := 0 to High() do
        Result.Shapes += [[x, y, z], 0];
      Exit;
    end;

    for i := 0 to High() do
      Result.Shapes += [[x, y, z], (90*getInt(i) * PI)/180];
  end;
end;

function TRSMapObject.MapToMM(me: TPoint = [0,0]; angle: Single = $FFFF): TPointArray; constref;
var
  coordinates: TPointArray;
begin
  if me = [0,0] then
    me := Self.Walker^.Position();

  coordinates := Self.Coordinates.FilterCircle([me.X, me.Y, 85]);
  coordinates := coordinates.Sorted(me);

  if angle = $FFFF then
    angle := Minimap.GetCompassAngle(False);

  Result := Self.Walker^.Points2MM(me, coordinates, angle);
end;

function TRSMapObject.MapToMS(me: TPoint = [0,0]; angle: Single = $FFFF): TPointArray; constref;
var
  coordinates: TPointArray;
begin
  if me = [0,0] then
    me := Self.Walker^.Position();

  coordinates := Self.Coordinates.FilterCircle([me.X, me.Y, 85]);
  coordinates := coordinates.Sorted(me);

  if angle = $FFFF then
    angle := Minimap.GetCompassAngle(False);

  coordinates := Self.Walker^.Points2MM(me, coordinates, angle);

  Result := Minimap.PointsToMS(coordinates, angle);
end;

function TRSMapObject.GetCuboidArray(me: TPoint = [0,0]; angle: Single = $FFFF): TCuboidExArray; constref;
var
  mmPoints: TPointArray;
begin
  if angle = $FFFF then
    angle := Minimap.GetCompassAngle(False);
  mmPoints := Self.MapToMM(me, angle);
  Result := Minimap.GetCuboidArrayMS(mmPoints, Self.Shapes, [0,0], angle);
end;

(*
## TRSMapObject.Find
```pascal
function TRSMapObject.Find(cuboidArray: TCuboidArray): T2DPointArray;
```
Internal TRSMapObject method responsible for filtering a TCuboidArray by what's visible in the mainscren.
This is meant to filter TRSMapObject.GetCuboidArray() so targets that are outside of the mainscreen are filtered out.
You will probably never need to use this directly.
*)
function TRSMapObject.Find(cuboidArray: TCuboidExArray): T2DPointArray;
var
  i: Int32;
  tpa: TPointArray;
  tmpFinder: TRSObjectFinder;
begin
  //if Self.Filter.Finder then
  //  tmpFinder := Self.Finder.Unlimited();

  cuboidArray := MainScreen.Filter(cuboidArray);

  for i := 0 to High(cuboidArray) do
  begin
    if Self.Filter.Finder then
    begin
      tpa := MainScreen.FindObject(tmpFinder, cuboidArray[i].Bounds()).Merge();
      if tpa = [] then
        Continue;

      tpa := cuboidArray[i].Filter(tpa);
      if tpa <> [] then
        Result += tpa;

      Continue;
    end;

    tpa := cuboidArray[i].ShapeFill();
    if tpa <> [] then
      Result += tpa;
  end;
end;

(*
## TRSMapObject.Visible
```pascal
function TRSMapObject.Visible(cuboidArray: TCuboidArray): Boolean;
```

Internal TRSMapObject method that returns true or false if we have TCuboids visible on the mainscreen.
You probably don't need to use this directly.
*)
function TRSMapObject.Visible(cuboidArray: TCuboidExArray): Boolean;
var
  i: Int32;
  tempFinder: TRSObjectFinder;
begin
  //if Self.Filter.Finder then
  //  tempFinder := Self.Finder.Unlimited();

  cuboidArray := MainScreen.Filter(cuboidArray);

  if not Self.Filter.Finder then
    Exit(cuboidArray <> []);

  for i := 0 to High(cuboidArray) do
    if MainScreen.FindObject(tempFinder, cuboidArray[i].Bounds()) <> [] then
      Exit(True);
end;


type
  TRSMapObjectArray = array of TRSMapObject;


function TRSMapObjectArray.FindAnyID(id: Int32): Int32;
begin
  for Result := 0 to High(Self) do
    if Self[Result].ID = id then
      Exit;
  Result := -1;
end;

function TRSMapObjectArray.FindAnyName(name: String): Int32;
begin
  name := LowerCase(name);
  for Result := 0 to High(Self) do
    if Self[Result].Name = name then
      Exit;
  Result := -1;
end;

function TRSMapObjectArray.FindAnyType(objType: Int32): Int32;
begin
  for Result := 0 to High(Self) do
    if Self[Result].ObjType = objType then
      Exit;
  Result := -1;
end;

function TRSMapObjectArray.FindAnyCategory(category: Int32): Int32;
begin
  for Result := 0 to High(Self) do
    if Self[Result].Category = category then
      Exit;
  Result := -1;
end;


function TRSMapObjectArray.FindAny(obj: Variant): Int32;
var
  str: String;
begin
  str := obj;
  if VarIsNumeric(obj) or str.IsDigit() then
    Exit(Self.FindAnyID(obj));
  Result := Self.FindAnyName(str);
end;

function TRSMapObjectArray.FindAllName(name: String): TIntegerArray;
var
  i: Int32;
begin
  name := LowerCase(name);
  for i := 0 to High(Self) do
    if Self[i].Name = name then
      Result += i;
end;

function TRSMapObjectArray.FindAllType(objType: Int32): TIntegerArray;
var
  i: Int32;
begin
  for i := 0 to High(Self) do
    if Self[i].ObjType = objType then
      Result += i;
end;

function TRSMapObjectArray.FindAllCategory(category: Int32): TIntegerArray;
var
  i: Int32;
begin
  for i := 0 to High(Self) do
    if Self[i].Category = category then
      Result += i;
end;

type
  TRSMapObjects = record
    Data: TJSONArray;
    Walker: PRSWalkerV2;
    Cache: TRSMapObjectArray;
  end;

function TRSMapObjects.Get(obj: Variant): TRSMapObject;
var
  i: Int32;
  str: String;
begin
  i := Self.Cache.FindAny(obj);
  if i > -1 then
    Exit(Self.Cache[i]);

  if VarIsNumeric(obj) then
  begin
    for i := 0 to  Self.Data.High() do
      if Self.Data.getJSONObject(i).getInt('id') = obj then
      begin
        Result := TRSMapObject.Setup(Self.Walker, Self.Data.getJSONObject(i));
        Result.Index := Length(Self.Cache);
        Self.Cache += Result;
        Exit;
      end;
    Exit;
  end;

  str := LowerCase(obj);

  if str.IsDigit() then
  begin
    for i := 0 to  Self.Data.High() do
      if Self.Data.getJSONObject(i).getInt('id') = obj then
      begin
        Result := TRSMapObject.Setup(Self.Walker, Self.Data.getJSONObject(i));
        Result.Index := Length(Self.Cache);
        Self.Cache += Result;
        Exit;
      end;
    Exit;
  end;

  for i := 0 to  Self.Data.High() do
    if LowerCase(Self.Data.getJSONObject(i).getString('name')) = str then
    begin
      Result := TRSMapObject.Setup(Self.Walker, Self.Data.getJSONObject(i));
        Result.Index := Length(Self.Cache);
        Self.Cache += Result;
      Exit;
    end;

  TerminateScript('Object: ' + ToStr(obj) + ' doesn''t exist.');
end;
