(*
# Map Objects
This file is responsible for interacting with map objects.
*)

{$DEFINE SRL_MAPOBJECTS_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL-T/osr.simba}
{$ENDIF}

type
  TRSMapObject = record
    ID: Int32;
    Name: String;
    ObjType:  Int32;
    Category: Int32;
    Actions: TStringArray;
    Coordinates: TPointArray;
    Size: Vector3;
    Rotations: TSingleArray;
    Finder: TRSObjectFinder;

    {%codetools off}
    //hidden so you don't touch.
    Walker: PRSWalkerV2;
    Index: Int32;
    {%codetools on}

    Filter: record
      Map:     Boolean;
      Minimap: Boolean;
      Finder:  Boolean;
      UpText:  Boolean;
    end;

  class var
    CurrentUpText: TStringArray;
    CurrentActionUpText: TStringArray;
    RedClicked: Boolean;
  end;

function TRSMapObject.Setup(pwalker: PRSWalkerV2; json: TJSONObject): TRSMapObject; static;
var
  i: Int32;
  x, y: Single;
begin
  Result.Walker := pwalker;
  Result.Filter := [True, True, True, True];

  Result.ID := json.getInt('id');
  Result.Name := json.getString('name');
  Result.ObjType := json.getInt('type');
  Result.Category := json.getInt('category');

  with json.getJSONArray('actions') do
    for i := 0 to High() do
      if getString(i) <> 'null' then
        Result.Actions += getString(i);

  with json.getJSONArray('size') do
  begin
    x := getInt(0) * 0.8;
    y := getInt(1) * 0.8;
    Result.Size := [x, y, getInt(2) / 40];
  end;

  if x <> y then
  begin
    with json.getJSONArray('coordinates') do
      for i := 0 to High() do
      begin
        with getJSONArray(i) do
          Result.Coordinates += [getInt(0), getInt(1)];
        Result.Rotations += (90*json.getJSONArray('rotations').getInt(i) * PI)/180;
      end;
    Exit;
  end;

  with json.getJSONArray('coordinates') do
    for i := 0 to High() do
      with getJSONArray(i) do
        Result.Coordinates += [getInt(0), getInt(1)];
  SetLength(Result.Rotations, Length(Result.Coordinates));
end;

function TRSMapObject.MapToMM(me: TPoint = [0,0]; angle: Single = $FFFF): TPointArray; constref;
var
  coordinates: TPointArray;
begin
  if me = [0,0] then
    me := Self.Walker^.Position();

  coordinates := Self.Coordinates.FilterCircle([me.X, me.Y, 85]);
  coordinates := coordinates.Sorted(me);

  if angle = $FFFF then
    angle := Minimap.GetCompassAngle(False);

  Result := Self.Walker^.Points2MM(me, coordinates, angle);
end;

function TRSMapObject.MapToMS(me: TPoint = [0,0]; angle: Single = $FFFF): TPointArray; constref;
var
  coordinates: TPointArray;
begin
  if me = [0,0] then
    me := Self.Walker^.Position();

  coordinates := Self.Coordinates.FilterCircle([me.X, me.Y, 85]);
  coordinates := coordinates.Sorted(me);

  if angle = $FFFF then
    angle := Minimap.GetCompassAngle(False);

  coordinates := Self.Walker^.Points2MM(me, coordinates, angle);

  Result := Minimap.PointsToMS(coordinates, angle);
end;

function TRSMapObject.GetCuboidArray(me: TPoint = [0,0]; angle: Single = $FFFF): TCuboidExArray; constref;
var
  mmPoints: TPointArray;
begin
  if angle = $FFFF then
    angle := Minimap.GetCompassAngle(False);
  mmPoints := Self.MapToMM(me, angle);
  Result := Minimap.GetCuboidArrayMS(mmPoints, Self.Size, [0,0], angle);
end;

(*
## TRSMapObject.Find
```pascal
function TRSMapObject.Find(cuboidArray: TCuboidArray): T2DPointArray;
```
Internal TRSMapObject method responsible for filtering a TCuboidArray by what's visible in the mainscren.
This is meant to filter TRSMapObject.GetCuboidArray() so targets that are outside of the mainscreen are filtered out.
You will probably never need to use this directly.
*)
function TRSMapObject.FindOnMainScreen(cuboidArray: TCuboidExArray): T2DPointArray;
var
  i: Int32;
  tpa: TPointArray;
begin
  cuboidArray := MainScreen.Filter(cuboidArray);

  for i := 0 to High(cuboidArray) do
  begin
    if Self.Filter.Finder then
    begin
      tpa := MainScreen.FindObject(Self.Finder, cuboidArray[i].Bounds()).Merge();
      if tpa = [] then
        Continue;

      tpa := cuboidArray[i].Filter(tpa);
      if tpa <> [] then
        Result += tpa;

      Continue;
    end;

    tpa := cuboidArray[i].ShapeFill();
    if tpa <> [] then
      Result += tpa;
  end;
end;

(*
## TRSMapObject.Visible
```pascal
function TRSMapObject.Visible(cuboidArray: TCuboidArray): Boolean;
```
Internal TRSMapObject method that returns true or false if we have TCuboids visible on the mainscreen.
You probably don't need to use this directly.
*)
function TRSMapObject.OnMainScreen(cuboidArray: TCuboidExArray): Boolean;
var
  i: Int32;
begin
  cuboidArray := MainScreen.Filter(cuboidArray);

  if not Self.Filter.Finder then
    Exit(cuboidArray <> []);

  for i := 0 to High(cuboidArray) do
    if MainScreen.FindObject(Self.Finder, cuboidArray[i].Bounds()) <> [] then
      Exit(True);
end;


(*
## TRSMapObject.Find
```pascal
function TRSMapObject.FindEx(out cuboids: TCuboidArray; out atpa: T2DPointArray): Boolean;
function TRSMapObject.Find(out atpa: T2DPointArray): Boolean;
```
TRSMapObject method used to find a {ref}`TRSMapObject`. If found returns true, if not returns false.
The "extended" method in particular is mostly meant for debugging and is the one used when you call `Debug(TRSObject)`.

Example:
```pascal
WriteLn RSObjects.GEBank.Find(atpa); //Be in ge and with a walker setup there.
Debug(atpa);
```
*)
function TRSMapObject.FindEx(out cuboids: TCuboidExArray; out atpa: T2DPointArray): Boolean;
begin
  if Self.Filter.Map then
  begin
    cuboids := Self.GetCuboidArray();
    if cuboids = [] then
      Exit;

    atpa := Self.FindOnMainScreen(cuboids);
  end
  else if Self.Filter.Finder then
    atpa := MainScreen.FindObject(Self.Finder).SortFrom(MainScreen.GetPlayerBox().Center());

  Result := atpa <> [];
end;

function TRSMapObject.Find(out atpa: T2DPointArray): Boolean;
var
  cuboids: TCuboidExArray;
begin
  Result := Self.FindEx(cuboids, atpa);
end;

(*
## TRSMapObject.IsVisible
```pascal
function TRSMapObject.IsVisible(): Boolean;
```
TRSMapObject method used to find a {ref}`TRSMapObject`. If found returns true, if not returns false.

Example:
```pascal
WriteLn RSObjects.GEBank.IsVisible(); //Be in ge and with a walker setup there.
```
*)
function TRSMapObject.IsVisible(): Boolean;
var
  cuboids: TCuboidExArray;
begin
  if Self.Filter.Map then
  begin
    cuboids := Self.GetCuboidArray();

    if cuboids = [] then
      Exit;

    Exit(Self.OnMainScreen(cuboids));
  end;

  if Self.Filter.Finder then
    Result := MainScreen.FindObject(Self.Finder) <> [];
end;



procedure TRSMapObject.Draw(out bitmap: TMufasaBitmap);
var
  me: TPoint;
  angle: Single;
  mmPoints: TPointArray;
  cuboids: TCuboidExArray;
  atpa: T2DPointArray;
begin
  me := Self.Walker^.Position();
  angle := Minimap.GetCompassAngle(False);

  mmPoints := Self.MapToMM(me, angle);
  cuboids := Minimap.GetCuboidArrayMS(mmPoints, Self.Size, [-1,-1], angle);

  bitmap.DrawTPA(mmPoints, $FF);

  Self.FindEx(cuboids, atpa);

  bitmap.DrawATPA(atpa);
  if atpa <> [] then
    bitmap.DrawTPA(atpa[0], $0);

  bitmap.DrawCuboidArray(cuboids, $00FFFF);
end;


procedure Debug(obj: TRSMapObject); overload;
var
  bitmap: TMufasaBitmap;
begin
  bitmap.FromClient();
  obj.Draw(bitmap);
  bitmap.Debug();
  bitmap.Free();
end;


type
  TRSMapObjectArray = array of TRSMapObject;

function TRSMapObjectArray.FindAnyID(id: Int32): Int32;
begin
  for Result := 0 to High(Self) do
    if Self[Result].ID = id then
      Exit;
  Result := -1;
end;

function TRSMapObjectArray.FindAnyName(name: String): Int32;
begin
  name := LowerCase(name);
  for Result := 0 to High(Self) do
    if LowerCase(Self[Result].Name) = name then
      Exit;
  Result := -1;
end;

function TRSMapObjectArray.FindAnyType(objType: Int32): Int32;
begin
  for Result := 0 to High(Self) do
    if Self[Result].ObjType = objType then
      Exit;
  Result := -1;
end;

function TRSMapObjectArray.FindAnyCategory(category: Int32): Int32;
begin
  for Result := 0 to High(Self) do
    if Self[Result].Category = category then
      Exit;
  Result := -1;
end;


function TRSMapObjectArray.FindAny(obj: Variant): Int32;
var
  str: String;
begin
  str := obj;
  if VarIsNumeric(obj) or str.IsDigit() then
    Exit(Self.FindAnyID(obj));
  Result := Self.FindAnyName(str);
end;

function TRSMapObjectArray.FindAllName(name: String): TIntegerArray;
var
  i: Int32;
begin
  name := LowerCase(name);
  for i := 0 to High(Self) do
    if Self[i].Name = name then
      Result += i;
end;

function TRSMapObjectArray.FindAllType(objType: Int32): TIntegerArray;
var
  i: Int32;
begin
  for i := 0 to High(Self) do
    if Self[i].ObjType = objType then
      Result += i;
end;

function TRSMapObjectArray.FindAllCategory(category: Int32): TIntegerArray;
var
  i: Int32;
begin
  for i := 0 to High(Self) do
    if Self[i].Category = category then
      Result += i;
end;

type
  TRSMapObjects = record
    Data: TJSONArray;
    Walker: PRSWalkerV2;
    Cache: TRSMapObjectArray;
  end;

function TRSMapObjects.Get(obj: Variant): TRSMapObject;
var
  i: Int32;
  str: String;
begin
  i := Self.Cache.FindAny(obj);
  if i > -1 then
    Exit(Self.Cache[i]);

  if VarIsNumeric(obj) then
  begin
    for i := 0 to  Self.Data.High() do
      if Self.Data.getJSONObject(i).getInt('id') = obj then
      begin
        Result := TRSMapObject.Setup(Self.Walker, Self.Data.getJSONObject(i));
        Result.Index := Length(Self.Cache);
        Self.Cache += Result;
        Exit;
      end;

    TerminateScript('Object with ID ' + ToStr(obj) + ' doesn''t exist on the loaded maps.');
  end;

  str := LowerCase(obj);

  if str.IsDigit() then
  begin
    for i := 0 to  Self.Data.High() do
      if Self.Data.getJSONObject(i).getInt('id') = obj then
      begin
        Result := TRSMapObject.Setup(Self.Walker, Self.Data.getJSONObject(i));
        Result.Index := Length(Self.Cache);
        Self.Cache += Result;
        Exit;
      end;

    TerminateScript('Object with ID ' + ToStr(obj) + ' doesn''t exist on the loaded maps.');
  end;

  for i := 0 to  Self.Data.High() do
    if LowerCase(Self.Data.getJSONObject(i).getString('name')) = str then
    begin
      Result := TRSMapObject.Setup(Self.Walker, Self.Data.getJSONObject(i));
      Result.Index := Length(Self.Cache);
      Self.Cache += Result;
      Exit;
    end;

  TerminateScript('Object ' + ToStr(obj) + ' doesn''t exist on the loaded maps.');
end;

function TRSMapObjects.Add(obj: TRSMapObject): TRSMapObject;
begin
  Result := obj;
  Result.Index := Length(Self.Cache);
  Self.Cache += Result;
end;

function TRSMapObjects.SetFinder(obj: Variant; finder: TRSObjectFinder): TRSMapObject;
begin
  Result := Self.Get(obj);
  Result.Finder := finder;

  Self.Cache[Result.Index].Finder := finder;
  WriteLn Self.Cache[Result.Index];
end;
