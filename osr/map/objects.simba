(*
# Map Objects
This file is responsible for interacting with map objects.
*)

{$DEFINE SRL_MAPOBJECTS_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL-T/osr.simba}
{$ENDIF}

type
  TRSMapObject = record
    ID: Int32;
    Name: String;
    ObjType:  Int32;
    Category: Int32;
    Actions: TStringArray;
    Coordinates: TPointArray;
    Size: Vector3;
    Rotations: TIntegerArray;
  end;

function TRSMapObject.Setup(json: TJSONObject): TRSMapObject; static;
var
  i: Int32;
begin
  Result.ID := json.getInt('id');
  Result.Name := json.getString('name');
  Result.ObjType := json.getInt('type');
  Result.Category := json.getInt('category');

  with json.getJSONArray('actions') do
    for i := 0 to High() do
      if getString(i) <> 'null' then
        Result.Actions += getString(i);

  with json.getJSONArray('coordinates') do
    for i := 0 to High() do
      with getJSONArray(i) do
        Result.Coordinates += [getInt(0), getInt(1)];

  with json.getJSONArray('size') do
  begin
    Result.Size.X := getInt(0);
    Result.Size.Y := getInt(1);
    if High() > 1 then
      Result.Size.Z := getInt(3)
    else
      Result.Size.Z := 0;
  end;

  with json.getJSONArray('rotations') do
    for i := 0 to High() do
      Result.Rotations += getInt(i);
end;

type
  TRSMapObjectArray = array of TRSMapObject;


function TRSMapObjectArray.FindAnyID(id: Int32): Int32;
begin
  for Result := 0 to High(Self) do
    if Self[Result].ID = id then
      Exit;
  Result := -1;
end;

function TRSMapObjectArray.FindAnyName(name: String): Int32;
begin
  name := LowerCase(name);
  for Result := 0 to High(Self) do
    if Self[Result].Name = name then
      Exit;
  Result := -1;
end;

function TRSMapObjectArray.FindAnyType(objType: Int32): Int32;
begin
  for Result := 0 to High(Self) do
    if Self[Result].ObjType = objType then
      Exit;
  Result := -1;
end;

function TRSMapObjectArray.FindAnyCategory(category: Int32): Int32;
begin
  for Result := 0 to High(Self) do
    if Self[Result].Category = category then
      Exit;
  Result := -1;
end;


function TRSMapObjectArray.FindAny(obj: Variant): Int32;
var
  str: String;
begin
  str := obj;
  if VarIsNumeric(obj) or str.IsDigit() then
    Exit(Self.FindAnyID(obj));
  Result := Self.FindAnyName(str);
end;

function TRSMapObjectArray.FindAllName(name: String): TIntegerArray;
var
  i: Int32;
begin
  name := LowerCase(name);
  for i := 0 to High(Self) do
    if Self[i].Name = name then
      Result += i;
end;

function TRSMapObjectArray.FindAllType(objType: Int32): TIntegerArray;
var
  i: Int32;
begin
  for i := 0 to High(Self) do
    if Self[i].ObjType = objType then
      Result += i;
end;

function TRSMapObjectArray.FindAllCategory(category: Int32): TIntegerArray;
var
  i: Int32;
begin
  for i := 0 to High(Self) do
    if Self[i].Category = category then
      Result += i;
end;

type
  TRSMapObjects = record
    Data: TJSONArray;
    Walker: PRSWalkerV2;
    Cache: TRSMapObjectArray;
  end;

function TRSMapObjects.Get(obj: Variant): TRSMapObject;
var
  i: Int32;
  str: String;
begin
  i := Self.Cache.FindAny(obj);
  if i > -1 then
    Exit(Self.Cache[i]);

  if VarIsNumeric(obj) then
  begin
    for i := 0 to  Self.Data.High() do
      if Self.Data.getJSONObject(i).getInt('id') = obj then
      begin
        Result := TRSMapObject.Setup(Self.Data.getJSONObject(i));
        Self.Cache += Result;
        Exit;
      end;
    Exit;
  end;

  str := LowerCase(obj);

  if str.IsDigit() then
  begin
    for i := 0 to  Self.Data.High() do
      if Self.Data.getJSONObject(i).getInt('id') = obj then
      begin
        Result := TRSMapObject.Setup(Self.Data.getJSONObject(i));
        Self.Cache += Result;
        Exit;
      end;
    Exit;
  end;

  for i := 0 to  Self.Data.High() do
    if LowerCase(Self.Data.getJSONObject(i).getString('name')) = str then
    begin
      Result := TRSMapObject.Setup(Self.Data.getJSONObject(i));
      Self.Cache += Result;
      Exit;
    end;
end;


function TRSMapObjects.GetCuboidArray(obj: Variant; me: TPoint = [0,0]): TCuboidExArray;
var
  o: TRSMapObject;
  coordinates: TPointArray;
begin
  if me = [0,0] then
    me := Self.Walker^.Position();

  o := Self.Get(obj);
  if o = []then
    TerminateScript('Object ' + ToStr(obj) + ' doesn''t exist.');

  coordinates := o.Coordinates.FilterDist(0, 120, me.X, me.Y);
  coordinates := coordinates.Sorted(me);

  //This is extremely wrong but will stay for now. shapearray should also be sorted and cropped.
  //Result := Self.Walker^.GetCuboidArrayMS(me, coordinates, Self.ShapeArray, [0, 0]);
  Result := [];
end;
