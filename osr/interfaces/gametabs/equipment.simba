(*
# Equipment
Methods to interact with the Equipment tab.
*)
{$DEFINE SRL_STATS_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL-T/osr.simba}
{$ENDIF}

type
(*
(ERSEquipmentSlot)=
## type ERSEquipmentSlot
```pascal
ERSEquipmentSlot = (
  HELM, SECONDARY_AMMO, CAPE, AMULET, AMMO, WEAPON,
  BODY, SHIELD, LEGS, GLOVES, FEET, RING
);
```
Enumerator of the equipment slots.
*)
  ERSEquipmentSlot = (
    HELM, SECONDARY_AMMO, CAPE, AMULET, AMMO, WEAPON,
    BODY, SHIELD, LEGS, GLOVES, FEET, RING
  );

(*
(ERSEquipmentButton)=
## type ERSEquipmentButton
```pascal
ERSEquipmentButton = (STATS, PRICES, DEATH, FOLLOWER);
```
Enumerator of the equipment buttons.
*)
  ERSEquipmentButton = (STATS, PRICES, DEATH, FOLLOWER);

(*
(TRSEquipment)=
## type TRSEquipment
```pascal
TRSEquipment = record(TRSInterface)
  Slots: TBoxArray;
end;
```
Main equipment type reponsible for handling it.
*)
  TRSEquipment = record(TRSInterface)
    Slots: TBoxArray;
  end;


(*
## Equipment.GetSlotBoxes
```pascal
function TRSEquipment.GetSlotBoxes(): TBoxArray;
```
Returns the boxes of slots in the equipment tab.

Example:
```pascal
Debug(Equipment.GetSlotBoxes());
```
*)
function TRSEquipment.GetSlotBoxes(): TBoxArray;
begin
  if Self.Slots <> [] then
    Exit(Self.Slots);

  Result := Grid(3,2, 35, 35, [6, 4], [Self.X1()+33, Self.Y1()+5]) +
            Grid(3,3, 35, 35, [21, 5], [Self.X1()+18, Self.Y1()+83]);

  Delete(Result, 0, 1);
  Delete(Result, 8, 1);
  Delete(Result, 9, 1);

  Self.Slots := Result;
end;

procedure TRSEquipment.Setup(); override;
begin
  inherited;

  Self.Name := 'Equipment';
  Self.ItemInterface.Name := Self.Name + '.ItemInterface';
  Self.ItemInterface.GetSearchBoxesFunction := @Self.GetSlotBoxes;
  Self.ItemInterface.DiscoverOffset := [2, 11, 2, -2];
end;

procedure TRSEquipment.SetupAlignment(Mode: ERSClientMode); override;
begin
  inherited;

  Self.Alignment.Left := [@GameTab.X1];
  Self.Alignment.Right := [@GameTab.X2];
  Self.Alignment.Top := [@GameTab.Y1];
  Self.Alignment.Bottom := [@GameTab.Y2];
end;


(*
## Equipment.IsOpen
```pascal
function TRSEquipment.IsOpen(): Boolean;
```
Returns true/false whether the equipment tab is open or not.

Example:
```pascal
WriteLn Equipment.IsOpen();
```
*)
function TRSEquipment.IsOpen(): Boolean;
begin
  Result := GameTabs.GetCurrentTab() = ERSGameTab.EQUIPMENT;
end;

(*
## Equipment.Open
```pascal
function TRSEquipment.Open(): Boolean;
```
Attempts to open the equipment tab.
Returns true if we succeed.

Example:
```pascal
WriteLn Equipment.Open();
```
*)
function TRSEquipment.Open(): Boolean;
begin
  Result := GameTabs.Open(ERSGameTab.EQUIPMENT);
end;


(*
## Equipment.GetButtons
```pascal
function TRSEquipment.GetButtons(): TRSButtonArray;
```
Returns a `TRSButtonArray` of the bottom equipment buttons.

Example:
```pascal
Debug(Equipment.GetButtons());
```
*)
function TRSEquipment.GetButtons(): TRSButtonArray;
begin
  Result := Self.FindButtons([[40,40]]);
end;

(*
## Equipment.GetButton
```pascal
function TRSEquipment.GetButton(button: ERSEquipmentButton): TRSButton;
```
Returns a `TRSButton` of the specified equipment button.

Example:
```pascal
Debug([Equipment.GetButton(ERSEquipmentButton.PRICES)]);
```
*)
function TRSEquipment.GetButton(button: ERSEquipmentButton): TRSButton;
var
  buttons: TRSButtonArray;
begin
  buttons := Self.GetButtons();
  if Length(buttons) = Length(ERSEquipmentButton) then
    Result := buttons[button];
end;


(*
## Equipment.FindItem
```pascal
function TRSEquipment.FindItem(item: TRSItem; out bounds: TBox): Boolean;
```
Returns true if we find the `item` specified in the equipment tab.
`bounds` will return a `TBox` of the item bounds.

Example:
```pascal
if Equipment.FindItem('Abyssal whip', bounds) then
  Debug(bounds);
```
*)
function TRSEquipment.FindItem(item: TRSItem; out bounds: TBox): Boolean;
begin
  if not Self.Open() then
    Exit;

  Result := Self.ItemInterface.Find([item], bounds);
end;


(*
## Equipment.Contains
```pascal
function TRSEquipment.ContainsItem(item: TRSItem): Boolean;
function TRSEquipment.ContainsAny(items: TRSItemArray): Boolean;
function TRSEquipment.ContainsAll(items: TRSItemArray): Boolean;
```
Same as {ref}`Equipment.FindItem` without the bounds.

Example:
```pascal
WriteLn Equipment.ContainsItem('Abyssal whip');
```
*)
function TRSEquipment.ContainsItem(Item: TRSItem): Boolean;
begin
  if not Self.Open() then
    Exit;
  Result := Self.ItemInterface.Contains(item);
end;

(*
## Equipment.ContainsAny
```pascal
function TRSEquipment.ContainsAny(items: TRSItemArray): Boolean;
```
Returns true if any item on the `items` parameter is found on the equipment tab.

Example:
```pascal
WriteLn Equipment.ContainsAny(['Abyssal whip', 'Dragon dagger']);
```
*)
function TRSEquipment.ContainsAny(items: TRSItemArray): Boolean;
begin
  if not Self.Open() then
    Exit;
  Result := Self.ItemInterface.ContainsAny(items);
end;

(*
## Equipment.ContainsAll
```pascal
function TRSEquipment.ContainsAll(items: TRSItemArray): Boolean;
```
Returns true if all items on the `items` parameter are found on the equipment tab.

Example:
```pascal
WriteLn Equipment.ContainsAll(['Abyssal whip', 'Dragon dagger']);
```
*)
function TRSEquipment.ContainsAll(items: TRSItemArray): Boolean;
begin
  if not Self.Open() then
    Exit;
  Result := Self.ItemInterface.ContainsAll(items);
end;


(*
## Equipment.DiscoverAll
```pascal
function TRSEquipment.DiscoverAllEx(): array of TRSItemArray;
function TRSEquipment.DiscoverAll(): TRSItemArray;
```
Returns all possible items found in the equipment.
The extended version returns an `array of TRSItemArray` while the other returns
a flat `TRSItemArray`.

Example:
```pascal
if Equipment.Open() then
  WriteLn Equipment.DiscoverAll();
```
*)
function TRSEquipment.DiscoverAllEx(): array of TRSItemArray;
begin
  if not Self.Open() then
    Exit;
  Result := Self.ItemInterface.DiscoverAllEx();
end;

function TRSEquipment.DiscoverAll(): TRSItemArray;
begin
  if not Self.Open() then
    Exit;
  Result := Self.ItemInterface.DiscoverAll();
end;

(*
## Equipment.Discover
```pascal
function TRSEquipment.Discover(slot: ERSEquipmentSlot): TRSItemArray;
function TRSInventory.Discover(slot: Int32): TRSItemArray;
```
Discovers what item is on the specified equipment `slot`.

Example:
```pascal
if Equipment.Open() then
  WriteLn Equipment.Discover(0);
```
*)
function TRSEquipment.Discover(slot: ERSEquipmentSlot): TRSItemArray;
begin
  if not Self.Open() then
    Exit;
  Result := Self.ItemInterface.Discover(Ord(slot));
end;

function TRSEquipment.Discover(slot: Int32): TRSItemArray; overload;
begin
  if not Self.Open() then
    Exit;
  Result := Self.ItemInterface.Discover(slot);
end;


(*
## Equipment.HoverItem
```pascal
function TRSEquipment.HoverItem(item: TRSItem): Boolean;
```
Attempts to hover an item, returns false if the item is not on the equipment tab.

Example:
```pascal
WriteLn Equipment.HoverItem('Abyssal whip');
```
*)
function TRSEquipment.HoverItem(item: TRSItem): Boolean;
begin
  if not Self.Open() then
    Exit;
  Result := Self.ItemInterface.MouseItem(item);
end;

(*
## Equipment.ClickItem
```pascal
function TRSEquipment.ClickItem(item: TRSItem; option: String = ''): Boolean;
```
Attempts to click an item, if an `option` is specified, that `option` will be
selected if it exists via right clicking if it's not the first action.

Returns false if the item is not found or the option specified doesn't exist.

Example:
```pascal
WriteLn Equipment.ClickItem('Abyssal whip');
```
*)
function TRSEquipment.ClickItem(item: TRSItem; option: String = ''): Boolean;
begin
  if not Self.Open() then
    Exit;
  Result := Self.ItemInterface.InteractItem(item, option);
end;

(*
## Equipment.CountItemStack
```pascal
function TRSEquipment.CountItemStack(item: TRSItem): Int32;
```
Attempts to count an item stack.
Realistically, it's only useful for ammo or any other few stackable items that
can be equipped.

Returns `-1` if the item is not found or if there's no stack number to read.

Example:
```pascal
WriteLn Equipment.CountItemStack('Broad bolts');
```
*)
function TRSEquipment.CountItemStack(item: TRSItem): Int32;
begin
  if not Self.IsOpen() then
    Exit;
  Result := Self.ItemInterface.CountStack(item);
end;


(*
## Equipment.IsSlotUsed
```pascal
function TRSEquipment.IsSlotUsed(b: TBox): Boolean;
function TRSEquipment.IsSlotUsed(slot: ERSEquipmentSlot): Boolean; overload;
```
Returns true if a slot is occupied.

Example:
```pascal
WriteLn Equipment.IsSlotUsed(ERSEquipmentSlot.WEAPON);
```
*)
function TRSEquipment.IsSlotUsed(b: TBox): Boolean;
begin
  // black with tolerance for when item is transparent
  Result := SRL.CountColor(CTS1(1118740, 35), b) > 0;
end;

function TRSEquipment.IsSlotUsed(slot: ERSEquipmentSlot): Boolean; overload;
begin
  Result := Self.Open() and Self.ItemInterface.SlotUsed(Ord(slot));
end;


(*
## Equipment.CountGear
```pascal
function TRSEquipment.CountGear(): Int32;
```
Returns the number of equipped items.

Example:
```pascal
WriteLn Equipment.CountGear();
```
*)
function TRSEquipment.CountGear(): Int32;
begin
  if not Self.Open() then
    Exit;
  Result := Self.ItemInterface.Count();
end;


procedure TRSEquipment.Draw(bitmap: TMufasaBitmap); override;
var
  buttons: TRSButtonArray;
begin
  if not Self.IsOpen() then
    Exit;

  inherited;

  bitmap.DrawBoxes(Self.GetSlotBoxes(), $00FFFF);
  buttons := Self.GetButtons();
  buttons.Draw(bitmap);
end;

var
(*
## var Equipment
Global Equipment variable.
*)
  Equipment: TRSEquipment;

procedure TRSClient.ClientModeChanged(); override;
begin
  inherited;

  Equipment.SetupAlignment(Self.Mode);
end;

procedure TSRL.Setup(); override;
begin
  inherited;

  Equipment.Setup();
end;

procedure TSRL.Debug(bitmap: TMufasaBitmap); override;
begin
  inherited;

  Equipment.Draw(bitmap);
end;
