{$DEFINE SRL_CHOOSEOPTION_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL-T/osr.simba}
{$ENDIF}

type
  TRSChooseOption_Option = record
    Text: String;
    Bounds: TBox;
    StringIndex, OptionIndex: Int32;
  end;

  TRSChooseOption_OptionArray = array of TRSChooseOption_Option;

  TRSChooseOption = record
    Bitmap: Int32;
    BitmapWidth: Int32;
    BitmapHeight: Int32;

    Bounds: TBox;
  end;

  TOptionCount = record
    Item: String;
    Count: Integer;
  end;
  TOptionCountArray = array of TOptionCount;

function TRSChooseOption.Find(): Boolean;
var
  TPA: TPointArray;
  ATPA: T2DPointArray;
  P: TPoint;
  B: TBox;
begin
  B := GetClientBounds();

  if FindBitmap(Self.Bitmap, P.X, P.Y) then
  begin
    P.Y += Self.BitmapHeight;

    if FindColors(TPA, 0, P.X, P.Y, B.X2, B.Y2) then
    begin
      ATPA := TPA.Cluster(1, 1);
      ATPA.SortByIndex(P, 0);

      Self.Bounds := ATPA[0].Bounds().Expand(-1);

      Exit(True);
    end;
  end;
end;

function TRSChooseOption.IsOpen(): Boolean; overload;
begin
  Result := Self.Find();
end;

function TRSChooseOption.IsOpen(WaitTime: Int32; Interval: Int32 = -1): Boolean; overload;
begin
  if (Interval = -1) then
    Interval := SRL.TruncatedGauss(50, 1500);

  Result := WaitUntil(Self.IsOpen(), Interval, WaitTime);
end;

function TRSChooseOption.Open(): Boolean;
begin
  Result := Self.IsOpen();

  if not Result then
  begin
    Mouse.Click(MOUSE_RIGHT);
    Result := Self.IsOpen(3000);
  end;
end;

procedure TRSChooseOption.Free();
begin
  FreeBitmap(Self.Bitmap);
end;

procedure TRSChooseOption.Setup();
begin
  Self.Bitmap := BitmapFromString(20, 18, 'meJxzD4l1pwAxkAsGj15Mv+DyGpogXBmyemL04lEzgHqxhgPxehkwwoEkN9NCLwMRcYRHL5rvSNVLPBhAvWQjAO6IcGE=');
  GetBitmapSize(Self.Bitmap, Self.BitmapWidth, Self.BitmapHeight);
  AddOnTerminate(@Self.Free);
end;

function TRSChooseOption.GetOptions(): TRSChooseOption_OptionArray;
var
  i: Int32;
  b: TBox;
begin
  if Self.Open() then
  begin
    if (Self.Bounds.Height() < 15) then
      Exit;

    SetLength(Result, Self.Bounds.Height() div 15);
    for i := 0 to High(Result) do
    begin
      b := [Self.Bounds.X1, Self.Bounds.Y1 + (i * 15), Self.Bounds.X2, Self.Bounds.Y1 + (i * 15) + 15];
      if (b.Y2 > Self.Bounds.Y2) then
        Exit;

      Result[i].Text := OCR.RecognizeStatic(b, TOCRThresholdFilter.Create(-1), RS_FONT_BOLD_12_SHADOW);
      Result[i].Bounds := b;
      Result[i].OptionIndex := i;
    end;
  end;
end;

{
  Counts the occurrences of a specific option within a given array of choices, filtering by an optional action prefix.

  Parameters:
    optionText: The text of the option to count.
    choices: An array of options where each item is of type TRSChooseOption_Option.
    actionFilter: A prefix to filter options by before counting, e.g., 'Take'. Default is 'Take'.
    caseSensitive: Specifies whether the text comparison should be case-sensitive. Default is true.

  Returns:
    The count of how many times the specified option appears in the choices array after applying the action filter.

  Example:
    // Assuming `choices` is already populated with options from the interface:
    writeln('Number of "Blue dragonhide" options: ', ChooseOption.CountOption('Blue dragonhide', choices));
}
function TRSChooseOption.CountOption(optionText: String; choices: TRSChooseOption_OptionArray; actionFilter: String = 'Take'; caseSensitive: Boolean = True): Integer;
var
  i: Int32;
  processedText: String;
begin
  Result := 0;
  if not caseSensitive then
    optionText := Lowercase(optionText);

  for i := 0 to High(choices) do begin
    processedText := choices[i].Text;
    if processedText.StartsWith(actionFilter) then
      processedText := processedText.Replace(actionFilter + ' ', '');

    if not caseSensitive then
      processedText := Lowercase(processedText);

    if processedText = optionText then
      Inc(Result);
  end;
end;

{
  Counts all unique options after applying an action filter from a set of choices presented in a context menu.

  Parameters:
    actionFilter: The filter to apply before counting, typically to remove a specific prefix like 'Take '. Default is 'Take'.

  Returns:
    An array where each element contains the item name and its count after filtering and counting each unique item in the choices.

  Example:
    // Assuming the context menu is open and ready to be read:
    var counts: TOptionCountArray;
    counts := ChooseOption.CountOptions();
    // Output each counted option and its occurrences:
    for i := 0 to High(counts) do
      writeln(counts[i].Item, ': ', counts[i].Count);
}
function TRSChooseOption.CountOptions(actionFilter: String = 'Take'): TOptionCountArray;
var
  choices: TRSChooseOption_OptionArray;
  i, idx: Int32;
  processedText: String;
  found: Boolean;
begin
  if not Self.Open() then Exit;
  Wait(0, 1000, wdLeft);
  choices := Self.GetOptions();

  for i := 0 to High(choices) do begin
    processedText := choices[i].Text;
    if processedText.StartsWith(actionFilter) then begin
      processedText := processedText.Replace(actionFilter + ' ', '');

      found := False;
      for idx := 0 to High(Result) do begin
        if Result[idx].Item = processedText then begin
          Inc(Result[idx].Count);
          found := True;
          Break;
        end;
      end;

      if not found then begin
        idx := Length(Result);
        SetLength(Result, idx + 1);
        Result[idx].Item := processedText;
        Result[idx].Count := 1;
      end;
    end;
  end;
end;


function TRSChooseOption.Close(): Boolean;
var
  boxes: TBoxArray;
  space: TBox;
begin
  if not Self.IsOpen() then
    Exit(True);

  space := Self.Bounds.Expand(100);
  space.LimitTo(GetClientBounds());

  boxes := Self.Bounds.Expand(50).Invert(space);
  if Length(boxes) = 0 then
    raise 'No space found to move mouse';

  Mouse.Move(boxes[Random(Length(boxes))], False, MOUSE_DISTRIBUTION_RANDOM);
  Result := WaitUntil(not Self.IsOpen(), 100, 1000);
end;


function TRSChooseOption.HasOption(text: TStringArray; out option: TRSChooseOption_Option; caseSensitive: Boolean = True; closeIfNotFound: Boolean = True): Boolean;
var
  choices: TRSChooseOption_OptionArray;
  i, j: Int32;
begin
  if not Self.Open() then
    Exit;

  Wait(0, 1000, wdLeft);
  choices := Self.GetOptions();

  for i := 0 to High(text) do
    for j := 0 to High(choices) do
    begin
      if not caseSensitive then
      begin
        text[i] := Lowercase(text[i]);
        choices[j].Text := Lowercase(choices[j].Text);
      end;

      if text[i] in choices[j].Text then
      begin
        option := choices[j];
        option.StringIndex := i;
        Exit(True);
      end;
    end;

  if closeIfNotFound then
  begin
    WaitEx(500, 250);
    Self.Close();
  end;
end;

function TRSChooseOption.HasOption(text: TStringArray; out index: Int32; caseSensitive: Boolean = True; closeIfNotFound: Boolean = True): Boolean; overload;
var
  option: TRSChooseOption_Option;
begin
  Result := Self.HasOption(text, option, caseSensitive, closeIfNotFound);
  if Result then
    index := option.StringIndex
  else
    index := -1;
end;

function TRSChooseOption.HasOption(text: TStringArray; caseSensitive: Boolean = True; closeIfNotFound: Boolean = True): Boolean; overload;
var
  i: Int32;
begin
  Result := Self.HasOption(text, i, caseSensitive, closeIfNotFound);
end;

function TRSChooseOption.HasOption(text: String; caseSensitive: Boolean = True; closeIfNotFound: Boolean = True): Boolean; overload;
begin
  Result := Self.HasOption([text], caseSensitive, closeIfNotFound);
end;


procedure TRSChooseOption.Select(option: TRSChooseOption_Option; mouseAction: Int32 = MOUSE_LEFT);
var
  from: TPoint;
  b: TBox;
  tmpMouse: TMouse;
begin
  b := option.Bounds;
  b := b.Expand(-1);

  from.X := b.X1;
  from.Y := b.Y1 + (b.Height() div 3);

  tmpMouse := Mouse;
  tmpMouse.MissChance := 0;
  tmpMouse.IdleInterval := 0;
  tmpMouse.Move(SRL.RandomPointEx(from, b));

  if (mouseAction <> MOUSE_MOVE) then
    tmpMouse.Click(mouseAction);
end;

function TRSChooseOption.Select(text: TStringArray; mouseAction: Int32 = MOUSE_LEFT; caseSensitive: Boolean = True; closeIfNotFound: Boolean = True): Boolean; overload;
var
  option: TRSChooseOption_Option;
begin
  Result := Self.HasOption(text, option, caseSensitive, closeIfNotFound);
  if Result then
    Self.Select(option, mouseAction);
end;

function TRSChooseOption.Select(text: String; mouseAction: Int32 = MOUSE_LEFT; caseSensitive: Boolean = True; closeIfNotFound: Boolean = True): Boolean; overload;
begin
  Result := Select([text], mouseAction, caseSensitive, closeIfNotFound);
end;


function TRSChooseOption.Hover(text: TStringArray; caseSensitive: Boolean = True; closeIfNotFound: Boolean = True): Boolean; overload;
begin
  Result := Select(text, MOUSE_MOVE, caseSensitive, closeIfNotFound);
end;

function TRSChooseOption.Hover(text: String; caseSensitive: Boolean = True; closeIfNotFound: Boolean = True): Boolean; overload;
begin
  Result := Select([text], MOUSE_MOVE, caseSensitive, closeIfNotFound);
end;

var
  ChooseOption: TRSChooseOption;

procedure TSRL.Setup(); override;
begin
  inherited;

  ChooseOption.Setup();
end;
