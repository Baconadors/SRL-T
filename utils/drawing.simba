{$DEFINE SRL_DRAWING_INCLUDED}
{$IFNDEF SRL_UTILS}
  {$I SRL-T/utils.simba}
{$ENDIF}

(*
# Drawing
Extends TMufasaBitmap with mostly drawing functions.
*)

type
  TMufasaBitmapArray = array of TMufasaBitmap;

const
  clBlack      = Int32($000000);
  clMaroon     = Int32($000080);
  clGreen      = Int32($008000);
  clOlive      = Int32($008080);
  clNavy       = Int32($800000);
  clPurple     = Int32($800080);
  clTeal       = Int32($808000);
  clRed        = Int32($0000FF);
  clLime       = Int32($00FF00);
  clYellow     = Int32($00FFFF);
  clBlue       = Int32($FF0000);
  clFuchsia    = Int32($FF00FF);
  clAqua       = Int32($FFFF00);
  clGray       = Int32($808080);
  clSilver     = Int32($C0C0C0);
  clLtGray     = Int32($C0C0C0);
  clMedGray    = Int32($A4A0A0);
  clDkGray     = Int32($808080);
  clWhite      = Int32($FFFFFF);
  clMoneyGreen = Int32($65BB85);
  clSkyBlue    = Int32($F0CAA6);
  clCream      = Int32($F0FBFF);
  clPink       = Int32($B3A2EA);
  clOrange     = Int32($0099FF);
  
var
  DEBUG_COLORS = [
    clRed, clBlue, clGreen, clLime, clMaroon, clOrange, clYellow, clAqua, clWhite, clPink, clPurple
  ];  
  
(*
## TMufasaBitmap.FromClient
```pascal
procedure TMufasaBitmap.FromClient(Area: TBox);
```
Copy client to bitmap.
*)

procedure TMufasaBitmap.Create(w, h: Int32);
begin
  Self.Init();
  Self.SetSize(w, h);
end;

function TMufasaBitmap.Copy(b: TBox): TMufasaBitmap; overload;
begin
  Result := Self.Copy(b.X1, b.Y1, b.X2, b.Y2);
end;

procedure TMufasaBitmap.Crop(b: TBox); overload;
begin
  Self.Crop(b.X1, b.Y1, b.X2, b.Y2);
end;

procedure TMufasaBitmap.FromClient(Area: TBox=[0,0,-1,-1]);
var
  W,H: Int32;
begin
  client.GetIOManager().GetDimensions(W,H);
  if Area = TBox([0,0,-1,-1]) then Area := [0,0,W-1,H-1];
  if (self <> nil) and (self.GetIndex() <> -1) then self.Free();
  Self.Init(client.GetMBitmaps);
  Self.CopyClientToBitmap(client.GetIOManager, True, Area.X1, Area.Y1, Area.X2, Area.Y2);
end;

procedure TMufasaBitmap.FromFile(path: String);
begin
  if (self <> nil) and (self.GetIndex() <> -1) then self.Free();
  Self.Init();
  Self.LoadFromFile(path);
end;

function TMufasaBitmap.Bounds(): TBox;
begin
  Result := [0, 0, Self.getWidth()-1, Self.getHeight()-1];
end;

procedure TMufasaBitmap.Clear(); constref; overload;
begin
  Self.DrawClear(0);
end;

procedure TMufasaBitmap.Clear(area: TBox); constref; overload;
begin
  Self.DrawBoxFilled(Area, False, 0);
end;

function TMufasaBitmap.GetPixel(p: TPoint): TColor; overload;
begin
  Result := Self.GetPixel(p.X, p.Y);
end;


function TMufasaBitmap.Data(): TIntegerArray;
begin
  SetLength(Result, Self.getWidth()*Self.getHeight());
  Move(Self.getData()^, Result[0], length(Result));
end;


(*
## TMufasaBitmap.ClearAllBut
```pascal
procedure TMufasaBitmap.ClearAllBut(Area: TBox);
```
Will clear the image, except for the given area.
*)
procedure TMufasaBitmap.ClearAllBut(Area: TBox); constref;
begin
  Self.DrawBoxFilled(Area, True, 0);
end;

(*
## TMufasaBitmap.AvgBrightness
```pascal
procedure TMufasaBitmap.AvgBrightness(Area: TBox = [0,0,-1,-1]);
```
Returns a value between 0 and 100 that defines how bright the image is.
*)
function TMufasaBitmap.AvgBrightness(Area: TBox = [0,0,-1,-1]): Int32; constref;
var
  x,y,t: Int64;
  px:TRGB32;
begin
  if Area.X2 < 0 then Area.X2 := self.GetWidth() + Area.X2;
  if Area.Y2 < 0 then Area.Y2 := self.GetHeight() + Area.Y2;

  for y:=Area.Y1 to Area.Y2 do
  begin
    t := 0;
    for x:=Area.X1 to Area.X2 do
    begin
      px := TRGB32(self.GetPixel(x,y));
      t += Round((px.R+px.G+px.B) / 3 * 0.392);
    end;
    Result += t div self.GetWidth();
  end;
  Result /= self.GetHeight();
end;

(*
## TMufasaBitmap.PeakBrightness
```pascal
procedure TMufasaBitmap.PeakBrightness(Area: TBox = [0,0,-1,-1]);
```
Returns the maximum brightness in the image in the range `0..100`.
*)
function TMufasaBitmap.PeakBrightness(Area: TBox = [0,0,-1,-1]): Int32; constref;
var
  x,y,t: Int64;
  px:TRGB32;
begin
  if Area.X2 < 0 then Area.X2 := self.GetWidth() + Area.X2;
  if Area.Y2 < 0 then Area.Y2 := self.GetHeight() + Area.Y2;

  for y:=Area.Y1 to Area.Y2 do
    for x:=Area.X1 to Area.X2 do
    begin 
      px := TRGB32(self.GetPixel(x,y));
      t := Max(Max(px.R,px.G),px.B);
      if t > Result then Result := t;
    end;
  Result := Round(Result / 255 * 100);
end;

procedure TMufasaBitmap.DrawBox(Box: TBox; Color: Int32); constref; overload;
begin
  Self.DrawTPA(EdgeFromBox(Box), Color);
end;

(*
## TMufasaBitmap.DrawBox
```pascal
procedure TMufasaBitmap.DrawBox(Center:TPoint; Radius:UInt32; Fill: Boolean; Color: Int32);
```
Draws a TBox onto the TMufasaBitmap
*)
procedure TMufasaBitmap.DrawBox(Center:TPoint; Radius:UInt32; Color: Int32); constref; overload;
begin
  with Center do
    Self.DrawBox([X - Radius, Y - Radius, X + Radius, Y + Radius], Color);
end;

procedure TMufasaBitmap.DrawBoxFilled(Center:TPoint; Radius:UInt32; Invert: Boolean; Color: Int32); constref; overload;
begin
  with Center do
    Self.DrawBoxFilled([X - Radius, Y - Radius, X + Radius, Y + Radius], Invert, Color);
end;

procedure TMufasaBitmap.DrawBoxes(Boxes: TBoxArray; Color: Int32); constref;
var
  Box: TBox;
begin
  for Box in Boxes do
    Self.DrawBox(Box, Color);
end;

procedure TMufasaBitmap.DrawBoxesFilled(Boxes: TBoxArray; Color: Int32); constref;
var
  Box: TBox;
begin
  for Box in Boxes do
    Self.DrawBoxFilled(Box, False, Color);
end;

(*
## TMufasaBitmap.DrawRect
```pascal
procedure TMufasaBitmap.DrawRect(Rect: TRectangle; Color: Int32);
```
Draws a TRectangle onto the TMufasaBitmap
*)
procedure TMufasaBitmap.DrawRect(Rect: TRectangle; Color: Int32); constref;
begin
  Self.DrawTPA(Rect.ToTPA().Connect(), Color);
end;

procedure TMufasaBitmap.DrawCuboid(Top, Btm: TRectangle; Color: Int32); constref;
begin
  Self.DrawRect([Top.Left, Top.Btm, Btm.Btm, Btm.Left], Color);
  Self.DrawRect([Top.Top, Top.Right, Btm.Right, Btm.Top], Color);
  Self.DrawRect([Top.Top, Btm.Top, Btm.Left, Top.Left], Color);
  Self.DrawRect([Top.Right, Btm.Right, Btm.Btm, Top.Btm], Color);
end;


procedure TMufasaBitmap.DrawCuboid(cuboid: TCuboid; color: Integer = $0000FF); constref; overload;
begin
  Self.DrawTPA(cuboid.Edges(), color);
end;

procedure TMufasaBitmap.DrawCuboidArray(cuboids: TCuboidArray; color: Integer = $0000FF); constref; overload;
var
  c: TCuboid;
begin
  for c in cuboids do
    Self.DrawCuboid(c, color);
end;

procedure TMufasaBitmap.DrawCuboid(cuboid: TCuboidEx; color: Int32 = $0000FF); constref; overload;
begin
  Self.DrawTPA(cuboid.Edges(), color);
end;

procedure TMufasaBitmap.DrawCuboidArray(cuboids: TCuboidExArray; color: Int32 = $0000FF); constref; overload;
var
  c: TCuboidEx;
begin
  for c in cuboids do
    Self.DrawCuboid(c, color);
end;


(*
## TMufasaBitmap.DrawPoly
```pascal
procedure TMufasaBitmap.DrawPoly(Poly: TPointArray; Color: Int32);
```
Draws a polygon onto the TMufasaBitmap
*)
procedure TMufasaBitmap.DrawPoly(Poly: TPointArray; Color: Int32); constref;
begin
  Self.DrawTPA(Poly.Connect(), Color);
end;

procedure TMufasaBitmap.DrawBitmap(Bitmap: TMufasaBitmap; TopLeft: TPoint); constref;
begin
  Bitmap.DrawTransparent(TopLeft.X, TopLeft.Y, Self);
end;

procedure TMufasaBitmap.DrawCross(Center: TPoint; Radius: Integer; Color: Int32); constref;
begin
  Radius := Round(Radius/2*Sqrt(2));

  if (Radius > 1) then
    with Center do
    begin
      Self.LineTo(Point(X - Radius, Y - Radius), Point(X + Radius, Y + Radius), Color);
      Self.LineTo(Point(X + Radius, Y - Radius), Point(X - Radius, Y + Radius), Color);
    end;
end;

procedure TMufasaBitmap.DrawBorderedCross(Center: TPoint; Radius: Integer; Color: Int32; Border: Int32 = $0); constref;
var
  cross, tpa: TPointArray;
begin
  Radius := Round(Radius/2*Sqrt(2));

  if (Radius > 1) then
    with Center do
    begin
      cross := TPAFromLine(Point(X - Radius, Y - Radius), Point(X + Radius, Y + Radius)) +
             TPAFromLine(Point(X + Radius, Y - Radius), Point(X - Radius, Y + Radius));
      tpa := cross.Grow(1);
      Self.DrawTPA(tpa, border);
      Self.DrawTPA(cross, Color);
    end;
end;

procedure TMufasaBitmap.DrawCircle(X, Y, Radius: Int32; Color: Int32); constref; overload;
begin
  Self.DrawTPA(TPAFromCircle(X, Y, Radius), Color);
end;

procedure TMufasaBitmap.DrawCircle(Center: TPoint; Radius: Int32; Color: Int32); constref; overload;
begin
  Self.DrawCircle(Center.X, Center.Y, Radius, Color);
end;

procedure TMufasaBitmap.DrawCircleFilled(Center: TPoint; Radius: Int32; Invert: Boolean; Color: Int32); constref; overload;
begin
  Self.DrawCircleFilled(Center.X, Center.Y, Radius, Invert, Color);
end;

procedure TMufasaBitmap.DrawCrosshairs(Center: TPoint; Size: Int32; Color: Int32); constref; overload;
begin
  Self.Rectangle([Center.X - Size, Center.Y, Center.X + Size, Center.Y], Color); 
  Self.Rectangle([Center.X, Center.Y - Size, Center.X, Center.Y + Size], Color);
end;

procedure TMufasaBitmap.DrawCrosshairs(Box: TBox; Size: Int32; BoxColor, CrosshairColor: Int32); constref; overload;
begin
  Self.DrawCrosshairs(Box.Middle, Size, CrosshairColor);
  Self.DrawBox(Box, BoxColor);
end;

procedure TMufasaBitmap.Debug();
begin
  ShowBitmap(Self);
end;

