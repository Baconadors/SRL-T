{$DEFINE SRL_DRAWING_INCLUDED}
{$IFNDEF SRL_UTILS}
  {$I SRL-T/utils.simba}
{$ENDIF}

(*
# Drawing
Extends TMufasaBitmap with mostly drawing functions.
*)

type
  TMufasaBitmapArray = array of TMufasaBitmap;

const
  clBlack      = Int32($000000);
  clMaroon     = Int32($000080);
  clGreen      = Int32($008000);
  clOlive      = Int32($008080);
  clNavy       = Int32($800000);
  clPurple     = Int32($800080);
  clTeal       = Int32($808000);
  clRed        = Int32($0000FF);
  clLime       = Int32($00FF00);
  clYellow     = Int32($00FFFF);
  clBlue       = Int32($FF0000);
  clFuchsia    = Int32($FF00FF);
  clAqua       = Int32($FFFF00);
  clGray       = Int32($808080);
  clSilver     = Int32($C0C0C0);
  clLtGray     = Int32($C0C0C0);
  clMedGray    = Int32($A4A0A0);
  clDkGray     = Int32($808080);
  clWhite      = Int32($FFFFFF);
  clMoneyGreen = Int32($65BB85);
  clSkyBlue    = Int32($F0CAA6);
  clCream      = Int32($F0FBFF);
  clPink       = Int32($B3A2EA);
  clOrange     = Int32($0099FF);
  
var
  DEBUG_COLORS = [
    clRed, clBlue, clGreen, clLime, clMaroon, clOrange, clYellow, clAqua, clWhite, clPink, clPurple
  ];  
  
(*
## TMufasaBitmap.FromClient
```pascal
procedure TMufasaBitmap.FromClient(Area: TBox);
```
Copy client to bitmap.
*)

procedure TMufasaBitmap.Create(w, h: Int32);
begin
  Self.Init();
  Self.SetSize(w, h);
end;

function TMufasaBitmap.Copy(b: TBox): TMufasaBitmap; overload;
begin
  Result := Self.Copy(b.X1, b.Y1, b.X2, b.Y2);
end;

procedure TMufasaBitmap.Crop(b: TBox); overload;
begin
  Self.Crop(b.X1, b.Y1, b.X2, b.Y2);
end;

procedure TMufasaBitmap.FromClient(Area: TBox=[0,0,-1,-1]);
var
  W,H: Int32;
begin
  client.GetIOManager().GetDimensions(W,H);
  if Area = TBox([0,0,-1,-1]) then Area := [0,0,W-1,H-1];
  if (self <> nil) and (self.GetIndex() <> -1) then self.Free();
  Self.Init(client.GetMBitmaps);
  Self.CopyClientToBitmap(client.GetIOManager, True, Area.X1, Area.Y1, Area.X2, Area.Y2);
end;

procedure TMufasaBitmap.FromFile(path: String);
begin
  if (self <> nil) and (self.GetIndex() <> -1) then self.Free();
  Self.Init();
  Self.LoadFromFile(path);
end;

function TMufasaBitmap.Bounds(): TBox;
begin
  Result := [0, 0, Self.getWidth()-1, Self.getHeight()-1];
end;

procedure TMufasaBitmap.Clear(); constref; overload;
begin
  Self.DrawClear(0);
end;

procedure TMufasaBitmap.Clear(area: TBox); constref; overload;
begin
  Self.DrawBoxFilled(Area, False, 0);
end;

function TMufasaBitmap.GetPixel(p: TPoint): TColor; overload;
begin
  Result := Self.GetPixel(p.X, p.Y);
end;


(*
## TMufasaBitmap.ClearAllBut
```pascal
procedure TMufasaBitmap.ClearAllBut(Area: TBox);
```

Will clear the image, except for the given area.
*)
procedure TMufasaBitmap.ClearAllBut(Area: TBox); constref;
begin
  Self.DrawBoxFilled(Area, True, 0);
end;

(*
## TMufasaBitmap.AvgBrightness
```pascal
procedure TMufasaBitmap.AvgBrightness(Area: TBox = [0,0,-1,-1]);
```

Returns a value between 0 and 100 that defines how bright the image is.
*)
function TMufasaBitmap.AvgBrightness(Area: TBox = [0,0,-1,-1]): Int32; constref;
var
  x,y,t: Int64;
  px:TRGB32;
begin
  if Area.X2 < 0 then Area.X2 := self.GetWidth() + Area.X2;
  if Area.Y2 < 0 then Area.Y2 := self.GetHeight() + Area.Y2;

  for y:=Area.Y1 to Area.Y2 do
  begin
    t := 0;
    for x:=Area.X1 to Area.X2 do
    begin
      px := TRGB32(self.GetPixel(x,y));
      t += Round((px.R+px.G+px.B) / 3 * 0.392);
    end;
    Result += t div self.GetWidth();
  end;
  Result /= self.GetHeight();
end;

(*
## TMufasaBitmap.PeakBrightness
```pascal
procedure TMufasaBitmap.PeakBrightness(Area: TBox = [0,0,-1,-1]);
```

Returns the maximum brightness in the image in the range `0..100`.
*)
function TMufasaBitmap.PeakBrightness(Area: TBox = [0,0,-1,-1]): Int32; constref;
var
  x,y,t: Int64;
  px:TRGB32;
begin
  if Area.X2 < 0 then Area.X2 := self.GetWidth() + Area.X2;
  if Area.Y2 < 0 then Area.Y2 := self.GetHeight() + Area.Y2;

  for y:=Area.Y1 to Area.Y2 do
    for x:=Area.X1 to Area.X2 do
    begin 
      px := TRGB32(self.GetPixel(x,y));
      t := Max(Max(px.R,px.G),px.B);
      if t > Result then Result := t;
    end;
  Result := Round(Result / 255 * 100);
end;

procedure TMufasaBitmap.DrawBox(Box: TBox; Color: Int32); constref; overload;
begin
  Self.DrawTPA(EdgeFromBox(Box), Color);
end;

(*
## TMufasaBitmap.DrawBox
```pascal
procedure TMufasaBitmap.DrawBox(Center:TPoint; Radius:UInt32; Fill: Boolean; Color: Int32);
```
Draws a TBox onto the TMufasaBitmap
*)
procedure TMufasaBitmap.DrawBox(Center:TPoint; Radius:UInt32; Color: Int32); constref; overload;
begin
  with Center do
    Self.DrawBox([X - Radius, Y - Radius, X + Radius, Y + Radius], Color);
end;

procedure TMufasaBitmap.DrawBoxFilled(Center:TPoint; Radius:UInt32; Invert: Boolean; Color: Int32); constref; overload;
begin
  with Center do
    Self.DrawBoxFilled([X - Radius, Y - Radius, X + Radius, Y + Radius], Invert, Color);
end;

procedure TMufasaBitmap.DrawBoxes(Boxes: TBoxArray; Color: Int32); constref;
var
  Box: TBox;
begin
  for Box in Boxes do
    Self.DrawBox(Box, Color);
end;

procedure TMufasaBitmap.DrawBoxesFilled(Boxes: TBoxArray; Color: Int32); constref;
var
  Box: TBox;
begin
  for Box in Boxes do
    Self.DrawBoxFilled(Box, False, Color);
end;

(*
## TMufasaBitmap.DrawRect
```pascal
procedure TMufasaBitmap.DrawRect(Rect: TRectangle; Color: Int32);
```

Draws a TRectangle onto the TMufasaBitmap
*)
procedure TMufasaBitmap.DrawRect(Rect: TRectangle; Color: Int32); constref;
begin
  Self.DrawTPA(Rect.ToTPA().Connect(), Color);
end;

procedure TMufasaBitmap.DrawCuboid(Top, Btm: TRectangle; Color: Int32); constref;
begin
  Self.DrawRect([Top.Left, Top.Btm, Btm.Btm, Btm.Left], Color);
  Self.DrawRect([Top.Top, Top.Right, Btm.Right, Btm.Top], Color);
  Self.DrawRect([Top.Top, Btm.Top, Btm.Left, Top.Left], Color);
  Self.DrawRect([Top.Right, Btm.Right, Btm.Btm, Top.Btm], Color);
end;


procedure TMufasaBitmap.DrawCuboid(cuboid: TCuboid; color: Integer = $0000FF); overload;
begin
  Self.DrawTPA(cuboid.Edges(), color);
end;

procedure TMufasaBitmap.DrawCuboidArray(cuboids: TCuboidArray; color: Integer = $0000FF); overload;
var
  c: TCuboid;
begin
  for c in cuboids do
    Self.DrawCuboid(c, color);
end;

procedure TMufasaBitmap.DrawCuboid(cuboid: TCuboidEx; color: Int32 = $0000FF); overload;
begin
  Self.DrawTPA(cuboid.Edges(), color);
end;

procedure TMufasaBitmap.DrawCuboidArray(cuboids: TCuboidExArray; color: Int32 = $0000FF); overload;
var
  c: TCuboidEx;
begin
  for c in cuboids do
    Self.DrawCuboid(c, color);
end;


(*
## TMufasaBitmap.DrawPoly
```pascal
procedure TMufasaBitmap.DrawPoly(Poly: TPointArray; Color: Int32);
```
Draws a polygon onto the TMufasaBitmap
*)
procedure TMufasaBitmap.DrawPoly(Poly: TPointArray; Color: Int32); constref;
begin
  Self.DrawTPA(Poly.Connect(), Color);
end;

procedure TMufasaBitmap.DrawBitmap(Bitmap: TMufasaBitmap; TopLeft: TPoint); constref;
begin
  Bitmap.DrawTransparent(TopLeft.X, TopLeft.Y, Self);
end;

procedure TMufasaBitmap.DrawCross(Center: TPoint; Radius: Integer; Color: Int32); constref;
begin
  Radius := Round(Radius/2*Sqrt(2));
  
  if (Radius > 1) then
    with Center do
    begin
      Self.LineTo(Point(X - Radius, Y - Radius), Point(X + Radius, Y + Radius), Color);
      Self.LineTo(Point(X + Radius, Y - Radius), Point(X - Radius, Y + Radius), Color);
    end;
end;

procedure TMufasaBitmap.DrawCircle(X, Y, Radius: Int32; Color: Int32); constref; overload;
begin
  Self.DrawTPA(TPAFromCircle(X, Y, Radius), Color);
end;

procedure TMufasaBitmap.DrawCircle(Center: TPoint; Radius: Int32; Color: Int32); constref; overload;
begin
  Self.DrawCircle(Center.X, Center.Y, Radius, Color);
end;

procedure TMufasaBitmap.DrawCircleFilled(Center: TPoint; Radius: Int32; Invert: Boolean; Color: Int32); constref; overload;
begin
  Self.DrawCircleFilled(Center.X, Center.Y, Radius, Invert, Color);
end;

procedure TMufasaBitmap.DrawCrosshairs(Center: TPoint; Size: Int32; Color: Int32); constref; overload;
begin
  Self.Rectangle([Center.X - Size, Center.Y, Center.X + Size, Center.Y], Color); 
  Self.Rectangle([Center.X, Center.Y - Size, Center.X, Center.Y + Size], Color);
end;

procedure TMufasaBitmap.DrawCrosshairs(Box: TBox; Size: Int32; BoxColor, CrosshairColor: Int32); constref; overload;
begin
  Self.DrawCrosshairs(Box.Middle, Size, CrosshairColor);
  Self.DrawBox(Box, BoxColor);
end;

procedure TMufasaBitmap.Debug();
begin
  ShowBitmap(Self);
end;

procedure Debug(ATPA: T2DPointArray); overload;
var
  Bitmap: TMufasaBitmap;
  I: Int32;
begin
  Bitmap.FromClient();
  
  for I := 0 to High(ATPA) do
    Bitmap.DrawTPA(ATPA[I], DEBUG_COLORS[I mod Length(DEBUG_COLORS)]);
  
  Bitmap.Debug();
  Bitmap.Free();
end;

procedure Debug(TPA: TPointArray); overload;
begin
  Debug([TPA]); 
end;

procedure Debug(R: TRectangle); overload;
begin
  Debug(R.ToTPA.Connect());
end;

procedure Debug(Box: TBox); overload;
begin
  Debug(EdgeFromBox(Box));
end;

procedure Debug(Boxes: TBoxArray); overload;
var
  ATPA: T2DPointArray;
  I: Int32;
begin
  SetLength(ATPA, Length(Boxes));
  for I := 0 to High(ATPA) do
    ATPA[I] := EdgeFromBox(Boxes[I]);
  
  Debug(ATPA);
end;

procedure Debug(Matrix: T2DIntegerArray); overload;
var
  Bitmap: TMufasaBitmap;
begin
  Bitmap.Init();
  Bitmap.DrawMatrix(Matrix);
  Bitmap.Debug();
  Bitmap.Free();
end;

procedure Debug(cuboid: TCuboid; color: Integer = $0000FF); overload;
var
  bitmap: TMufasaBitmap;
begin
  bitmap.FromClient();
  bitmap.DrawCuboid(cuboid, color);
  bitmap.Debug();
  bitmap.Free();
end;

procedure Debug(cuboids: TCuboidArray; color: Integer = $0000FF); overload;
var
  bitmap: TMufasaBitmap;
begin
  bitmap.FromClient();
  bitmap.DrawCuboidArray(cuboids, color);
  bitmap.Debug();
  bitmap.Free();
end;

procedure Debug(cuboid: TCuboidEx; color: Integer = $0000FF); overload;
var
  bitmap: TMufasaBitmap;
begin
  bitmap.FromClient();
  bitmap.DrawCuboid(cuboid, color);
  bitmap.Debug();
  bitmap.Free();
end;

procedure Debug(cuboids: TCuboidExArray; color: Integer = $0000FF); overload;
var
  bitmap: TMufasaBitmap;
begin
  bitmap.FromClient();
  bitmap.DrawCuboidArray(cuboids, color);
  bitmap.Debug();
  bitmap.Free();
end;


procedure PlotGraph(xAxis, yAxis: String; dataNames: TStringArray; data: T2DPointArray; colors: TIntegerArray; connect: Boolean = True);
var
  bmp, tmp, rotated: TMufasaBitmap;
  xMax, yMax, i, j, x: Int32;
  p: TPoint;
begin
  if Length(colors) < Length(data) then
    TerminateScript('Not enough colors to draw your data');

  bmp.Init();
  bmp.setFontAntialiasing(True);

  for i := 0 to High(data) do
    for j := 0 to High(data[i]) do
    begin
      data[i,j].X += 20;
      data[i,j].Y += 20;
      xMax := Max(data[i,j].X, xMax);
      yMax := Max(data[i,j].Y, yMax);
    end;

  bmp.SetSize(xMax+40, yMax + 80 + (40 * High(data)));

  for x := 0 to bmp.GetWidth() do
  begin
    if Frac(x / 2) = 0 then
      bmp.LineTo([x, 0], [x, bmp.GetHeight()], $F5F5F5)
    else
      bmp.LineTo([x, 0], [x, bmp.GetHeight()], $FFFFFF);
  end;

  bmp.LineTo([20,20], [20, yMax], $0);
  bmp.LineTo([20, yMax], [xMax+20, yMax], $0);

  bmp.setFontSize(15);

  bmp.DrawText(xAxis, [30, yMax + 5], $11);

  tmp.Init();
  tmp.SetSize(bmp.getHeight() div 2, 40);
  tmp.setFontSize(15);
  tmp.setFontAntialiasing(True);
  tmp.DrawText(yAxis, [0,0], $11);
  rotated.Init();
  rotated.setFontAntialiasing(True);
  tmp.RotateBitmap(PI/2, rotated);
  rotated.SetTransparentColor($0);

  bmp.DrawBitmap(rotated, [4, bmp.getHeight() div 2 - (40 * High(data)) - 90]);
  tmp.Free();
  rotated.Free();

  for i := 0 to High(data) do
  begin
    if connect then
    begin
      for j := 0 to High(data[i])-1 do
        bmp.DrawTPA(TPAFromLine(data[i,j], data[i,j+1]), colors[i]);
    end
    else
      bmp.DrawTPA(data[i], colors[i]);

    if i <= Length(dataNames) then
    begin
      p := [bmp.getWidth() div 2, yMax + 40 + 30 * i];
      bmp.DrawBoxFilled(p.Offset(0,5), 5, False, colors[i]);
      bmp.DrawText(dataNames[i], p.Offset(10,0), $0);
    end;
  end;

  bmp.Debug();
  bmp.Free();
end;

procedure PlotGraph(xAxis, yAxis: String; dataNames: TStringArray; data: array of Vector2Array; colors: TIntegerArray; connect: Boolean = True); overload;
var
  i, j: Int32;
  arr: T2DPointArray;
begin
  SetLength(arr, Length(data));
  for i := 0 to High(data) do
  begin
    SetLength(arr[i], Length(data[i]));
    for j := 0 to High(data[i]) do
      arr[i,j] := [Round(data[i,j].X * 10), Round(data[i,j].Y * 10)];
  end;

  PlotGraph(xAxis, yAxis, dataNames, arr, colors, connect);
end;

